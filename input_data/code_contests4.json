[
    {
        "description": "Captain Marmot wants to prepare a huge and important battle against his enemy, Captain Snake. For this battle he has n regiments, each consisting of 4 moles.\n\nInitially, each mole i (1 ≤ i ≤ 4n) is placed at some position (xi, yi) in the Cartesian plane. Captain Marmot wants to move some moles to make the regiments compact, if it's possible.\n\nEach mole i has a home placed at the position (ai, bi). Moving this mole one time means rotating his position point (xi, yi) 90 degrees counter-clockwise around it's home point (ai, bi).\n\nA regiment is compact only if the position points of the 4 moles form a square with non-zero area.\n\nHelp Captain Marmot to find out for each regiment the minimal number of moves required to make that regiment compact, if it's possible.\n\nInput\n\nThe first line contains one integer n (1 ≤ n ≤ 100), the number of regiments.\n\nThe next 4n lines contain 4 integers xi, yi, ai, bi ( - 104 ≤ xi, yi, ai, bi ≤ 104).\n\nOutput\n\nPrint n lines to the standard output. If the regiment i can be made compact, the i-th line should contain one integer, the minimal number of required moves. Otherwise, on the i-th line print \"-1\" (without quotes).\n\nExamples\n\nInput\n\n4\n1 1 0 0\n-1 1 0 0\n-1 1 0 0\n1 -1 0 0\n1 1 0 0\n-2 1 0 0\n-1 1 0 0\n1 -1 0 0\n1 1 0 0\n-1 1 0 0\n-1 1 0 0\n-1 1 0 0\n2 2 0 1\n-1 0 0 -2\n3 0 0 -2\n-1 1 -2 0\n\n\nOutput\n\n1\n-1\n3\n3\n\nNote\n\nIn the first regiment we can move once the second or the third mole.\n\nWe can't make the second regiment compact.\n\nIn the third regiment, from the last 3 moles we can move once one and twice another one.\n\nIn the fourth regiment, we can move twice the first mole and once the third mole.",
        "task_name": "474_C. Captain Marmot",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n# import threading\n# threading.stack_size(2**27)\n# import sys\n# sys.setrecursionlimit(10**7)\nfrom sys import stdin, stdout\nimport bisect            #c++ upperbound\nimport math\nimport heapq\ni_m=9223372036854775807\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nimport math  \ndef GCD(x, y): \n    x=abs(x)\n    y=abs(y)\n    if(min(x,y)==0):\n        return max(x,y)\n    while(y): \n        x, y = y, x % y \n    return x \ndef Divisors(n) : \n    l = []  \n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                l.append(n//i)\n    return l\n \n\ndef SieveOfEratosthenes(n): \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    f=[]\n    for p in range(2, n): \n        if prime[p]: \n            f.append(p)\n    return f\nq=[]       \ndef dfs(n,d,v,c):\n    global q\n    v[n]=1\n    x=d[n]\n    q.append(n)\n    j=c\n    for i in x:\n        if i not in v:\n            f=dfs(i,d,v,c+1)\n            j=max(j,f)\n            # print(f)\n    return j\n \ndef help():\n    res = 1000\n    l = [list(map(int, input().split())) for _ in range(4)]\n    for _1 in range(4):\n        for _2 in range(4):\n            for _3 in range(4):\n                for _4 in range(4):\n                    for i in range(_1): rot(l[0])\n                    for i in range(_2): rot(l[1])\n                    for i in range(_3): rot(l[2])\n                    for i in range(_4): rot(l[3])\n                    if square(l):\n                        res = min(res, _1 + _2 + _3 + _4)\n                    for i in range(4-_1): rot(l[0])\n                    for i in range(4-_2): rot(l[1])\n                    for i in range(4-_3): rot(l[2])\n                    for i in range(4-_4): rot(l[3])\n    return res\n \ndef rot(l):\n    x = l[0]\n    y = l[1]\n    homex = l[2]\n    homey = l[3]\n    yabove = y - homey\n    xright = x - homex\n    newx = homex - yabove\n    newy = homey + xright\n    l[0] = newx\n    l[1] = newy\n    return l\n \ndef square(l):\n    distances = list()\n    for i in range(4):\n        for j in range(i + 1, 4):\n            distances.append(dist(l[i], l[j]))\n    distances.sort()\n    if distances[0] < 0.000001: return False #same point\n    different = 0\n    for i in range(len(distances) - 1):\n        if abs(distances[i] - distances[i+1]) > 0.000001:\n            different += 1\n    return different == 1\n \ndef dist(a, b):\n    return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\n\"\"\"*******************************************************\"\"\"\ndef main():\n    n = int(input())\n    for _ in range(n):\n        t = help()\n        print(-1 if t == 1000 else t)\n\n\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'R' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'R' [0]:\n        A.append(sign*numb)\n    return A\n \n# threading.Thread(target=main).start()\nif __name__== \"__main__\":\n  main()",
        "correct": true,
        "task_id": "0280"
    },
    {
        "description": "The Saratov State University Olympiad Programmers Training Center (SSU OPTC) has n students. For each student you know the number of times he/she has participated in the ACM ICPC world programming championship. According to the ACM ICPC rules, each person can participate in the world championship at most 5 times.\n\nThe head of the SSU OPTC is recently gathering teams to participate in the world championship. Each team must consist of exactly three people, at that, any person cannot be a member of two or more teams. What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least k times?\n\nInput\n\nThe first line contains two integers, n and k (1 ≤ n ≤ 2000; 1 ≤ k ≤ 5). The next line contains n integers: y1, y2, ..., yn (0 ≤ yi ≤ 5), where yi shows the number of times the i-th person participated in the ACM ICPC world championship.\n\nOutput\n\nPrint a single number — the answer to the problem.\n\nExamples\n\nInput\n\n5 2\n0 4 5 1 0\n\n\nOutput\n\n1\n\n\nInput\n\n6 4\n0 1 2 3 4 5\n\n\nOutput\n\n0\n\n\nInput\n\n6 5\n0 0 0 0 0 0\n\n\nOutput\n\n2\n\nNote\n\nIn the first sample only one team could be made: the first, the fourth and the fifth participants.\n\nIn the second sample no teams could be created.\n\nIn the third sample two teams could be created. Any partition into two teams fits.",
        "task_name": "432_A. Choosing Teams",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import math\n\nn, k = raw_input().split()\nn, k = int(n), int(k)\narr = map(int,raw_input().split())\ncount = 0.0\n\nfor i in range(n):\n    if arr[i] + k <= 5:\n        count += 1.0\n\nprint(int(math.floor(count / 3)))",
        "correct": true,
        "task_id": "4493"
    },
    {
        "description": "There is a card game called \"Durak\", which means \"Fool\" in Russian. The game is quite popular in the countries that used to form USSR. The problem does not state all the game's rules explicitly — you can find them later yourselves if you want.\n\nTo play durak you need a pack of 36 cards. Each card has a suit (\"S\", \"H\", \"D\" and \"C\") and a rank (in the increasing order \"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\" and \"A\"). At the beginning of the game one suit is arbitrarily chosen as trump. \n\nThe players move like that: one player puts one or several of his cards on the table and the other one should beat each of them with his cards.\n\nA card beats another one if both cards have similar suits and the first card has a higher rank then the second one. Besides, a trump card can beat any non-trump card whatever the cards’ ranks are. In all other cases you can not beat the second card with the first one.\n\nYou are given the trump suit and two different cards. Determine whether the first one beats the second one or not.\n\nInput\n\nThe first line contains the tramp suit. It is \"S\", \"H\", \"D\" or \"C\".\n\nThe second line contains the description of the two different cards. Each card is described by one word consisting of two symbols. The first symbol stands for the rank (\"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\" and \"A\"), and the second one stands for the suit (\"S\", \"H\", \"D\" and \"C\").\n\nOutput\n\nPrint \"YES\" (without the quotes) if the first cards beats the second one. Otherwise, print \"NO\" (also without the quotes).\n\nExamples\n\nInput\n\nH\nQH 9S\n\n\nOutput\n\nYES\n\n\nInput\n\nS\n8D 6D\n\n\nOutput\n\nYES\n\nInput\n\nC\n7H AS\n\n\nOutput\n\nNO",
        "task_name": "106_A. Card Game",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "s = raw_input()\ns2 = raw_input().split()\n\nm1 = '6789TJQKA'\n\ni = 0\nfor ts in m1:\n    if ts == s2[0][0]:\n        r1 = i\n    i+=1\n\ni = 0\nfor ts in m1:\n    if ts == s2[1][0]:\n        r2 = i\n    i+=1\n\n#print r1, r2\n\nif s2[0][1] != s2[1][1] and s2[0][1] == s[0]:\n    print ('YES')\nelif s2[0][1] == s2[1][1] and r1 > r2:\n    print('YES')\nelse:\n    print('NO')\n",
        "correct": true,
        "task_id": "1153"
    },
    {
        "description": "You have a knapsack with the capacity of W. There are also n items, the i-th one has weight w_i. \n\nYou want to put some of these items into the knapsack in such a way that their total weight C is at least half of its size, but (obviously) does not exceed it. Formally, C should satisfy: ⌈ W/2⌉ ≤ C ≤ W. \n\nOutput the list of items you will put into the knapsack or determine that fulfilling the conditions is impossible. \n\nIf there are several possible lists of items satisfying the conditions, you can output any. Note that you don't have to maximize the sum of weights of items in the knapsack.\n\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.\n\nThe first line of each test case contains integers n and W (1 ≤ n ≤ 200 000, 1≤ W ≤ 10^{18}). \n\nThe second line of each test case contains n integers w_1, w_2, ..., w_n (1 ≤ w_i ≤ 10^9) — weights of the items.\n\nThe sum of n over all test cases does not exceed 200 000.\n\nOutput\n\nFor each test case, if there is no solution, print a single integer -1. \n\nIf there exists a solution consisting of m items, print m in the first line of the output and m integers j_1, j_2, ..., j_m (1 ≤ j_i ≤ n, all j_i are distinct) in the second line of the output — indices of the items you would like to pack into the knapsack.\n\nIf there are several possible lists of items satisfying the conditions, you can output any. Note that you don't have to maximize the sum of weights items in the knapsack.\n\nExample\n\nInput\n\n\n3\n1 3\n3\n6 2\n19 8 19 69 9 4\n7 12\n1 1 1 17 1 1 1\n\n\nOutput\n\n\n1\n1\n-1\n6\n1 2 3 5 6 7\n\nNote\n\nIn the first test case, you can take the item of weight 3 and fill the knapsack just right.\n\nIn the second test case, all the items are larger than the knapsack's capacity. Therefore, the answer is -1.\n\nIn the third test case, you fill the knapsack exactly in half.",
        "task_name": "1446_A. Knapsack",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from __future__ import division, print_function\n \nimport os\nimport sys\nfrom io import BytesIO, IOBase\nsys.setrecursionlimit(10**5)\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \n \ndef main():\n    pass\n \n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\nt=int(input())\nimport math\nwhile t:\n    t-=1\n    n,W=map(int,input().split())\n    arr=list(map(int,input().split()))\n    dicty={}\n    check=True\n    for i in range(n):\n        if arr[i]>=math.ceil(W/2) and arr[i]<=W:\n            print(1)\n            print(i+1)\n            check=False\n            break\n        elif arr[i]>W:\n            dicty[i]=1\n    if check:\n        idxs=[]\n        i=0\n        sm=0\n        check=True\n        while i!=n:\n            if i not in dicty:\n                if sm+arr[i]<=W:\n                    sm+=arr[i]\n                    idxs.append(i+1)\n                if sm>=math.ceil(W/2) and sm<=W:\n                    print(len(idxs))\n                    print(*idxs)\n                    check=False\n                    break\n            i+=1\n        if check:\n            print(-1)\n            \n        ",
        "correct": true,
        "task_id": "1328"
    },
    {
        "description": "Petya has an array a consisting of n integers. He wants to remove duplicate (equal) elements.\n\nPetya wants to leave only the rightmost entry (occurrence) for each element of the array. The relative order of the remaining unique elements should not be changed.\n\nInput\n\nThe first line contains a single integer n (1 ≤ n ≤ 50) — the number of elements in Petya's array.\n\nThe following line contains a sequence a_1, a_2, ..., a_n (1 ≤ a_i ≤ 1 000) — the Petya's array.\n\nOutput\n\nIn the first line print integer x — the number of elements which will be left in Petya's array after he removed the duplicates.\n\nIn the second line print x integers separated with a space — Petya's array after he removed the duplicates. For each unique element only the rightmost entry should be left.\n\nExamples\n\nInput\n\n6\n1 5 5 1 6 1\n\n\nOutput\n\n3\n5 6 1 \n\n\nInput\n\n5\n2 4 2 4 4\n\n\nOutput\n\n2\n2 4 \n\n\nInput\n\n5\n6 6 6 6 6\n\n\nOutput\n\n1\n6 \n\nNote\n\nIn the first example you should remove two integers 1, which are in the positions 1 and 4. Also you should remove the integer 5, which is in the position 2.\n\nIn the second example you should remove integer 2, which is in the position 1, and two integers 4, which are in the positions 2 and 4.\n\nIn the third example you should remove four integers 6, which are in the positions 1, 2, 3 and 4.",
        "task_name": "978_A. Remove Duplicates",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split(' ')))\n\na = a[::-1]\nans = []\nvis = set({})\nfor ai in a:\n\tif ai in vis:\n\t\tcontinue\n\telse:\n\t\tans.append(ai)\n\t\tvis.add(ai)\nprint(len(ans))\nprint(' '.join(map(str,ans[::-1])))\n",
        "correct": true,
        "task_id": "1683"
    }
]