[
    {
        "description": "This is the easy version of the problem. The difference between the versions is that in the easy version all prices a_i are different. You can make hacks if and only if you solved both versions of the problem.\n\nToday is Sage's birthday, and she will go shopping to buy ice spheres. All n ice spheres are placed in a row and they are numbered from 1 to n from left to right. Each ice sphere has a positive integer price. In this version all prices are different.\n\nAn ice sphere is cheap if it costs strictly less than two neighboring ice spheres: the nearest to the left and the nearest to the right. The leftmost and the rightmost ice spheres are not cheap. Sage will choose all cheap ice spheres and then buy only them.\n\nYou can visit the shop before Sage and reorder the ice spheres as you wish. Find out the maximum number of ice spheres that Sage can buy, and show how the ice spheres should be reordered.\n\nInput\n\nThe first line contains a single integer n (1 ≤ n ≤ 10^5) — the number of ice spheres in the shop.\n\nThe second line contains n different integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9) — the prices of ice spheres.\n\nOutput\n\nIn the first line print the maximum number of ice spheres that Sage can buy.\n\nIn the second line print the prices of ice spheres in the optimal order. If there are several correct answers, you can print any of them.\n\nExample\n\nInput\n\n\n5\n1 2 3 4 5\n\n\nOutput\n\n\n2\n3 1 4 2 5 \n\nNote\n\nIn the example it's not possible to place ice spheres in any order so that Sage would buy 3 of them. If the ice spheres are placed like this (3, 1, 4, 2, 5), then Sage will buy two spheres: one for 1 and one for 2, because they are cheap.",
        "task_name": "1419_D1. Sage's Birthday (easy version)",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "\n# Author : raj1307 - Raj Singh\n# Date   : 19.09.2020\n\nfrom __future__ import division, print_function\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li():  return list(mi())\n\ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import log,sqrt,factorial,cos,tan,sin,radians\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *\n#import threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))\n\ndef ceil(x,y):\n    if x%y==0:\n        return x//y\n    else:\n        return x//y+1\n\ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n\n\n\ndef read():\n    sys.stdin  = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n\n\n\n\n\n\ndef main():\n    \n    \n    #for _ in range(ii()):\n        \n    \n    \n    n=ii()\n    a=li()\n    ans=0\n\n    i=0\n    j=n-1\n    b=[]\n    f=0\n    for k in range(n):\n\n        if f==0:\n            b.append(a[j])\n            j-=1\n            f^=1\n        else:\n            b.append(a[i])\n            i+=1\n            f^=1\n\n    for i in range(1,n-1):\n        if b[i]<b[i-1] and b[i]<b[i+1]:\n            ans+=1\n\n\n    print(ans)\n    print(*b)\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n\n# Comment Read()\n",
        "correct": false,
        "task_id": "2166"
    },
    {
        "description": "Polycarp is mad about coding, that is why he writes Sveta encoded messages. He calls the median letter in a word the letter which is in the middle of the word. If the word's length is even, the median letter is the left of the two middle letters. In the following examples, the median letter is highlighted: contest, info. If the word consists of single letter, then according to above definition this letter is the median letter. \n\nPolycarp encodes each word in the following way: he writes down the median letter of the word, then deletes it and repeats the process until there are no letters left. For example, he encodes the word volga as logva.\n\nYou are given an encoding s of some word, your task is to decode it. \n\nInput\n\nThe first line contains a positive integer n (1 ≤ n ≤ 2000) — the length of the encoded word.\n\nThe second line contains the string s of length n consisting of lowercase English letters — the encoding.\n\nOutput\n\nPrint the word that Polycarp encoded.\n\nExamples\n\nInput\n\n5\nlogva\n\n\nOutput\n\nvolga\n\n\nInput\n\n2\nno\n\n\nOutput\n\nno\n\n\nInput\n\n4\nabba\n\n\nOutput\n\nbaba\n\nNote\n\nIn the first example Polycarp encoded the word volga. At first, he wrote down the letter l from the position 3, after that his word looked like voga. After that Polycarp wrote down the letter o from the position 2, his word became vga. Then Polycarp wrote down the letter g which was at the second position, the word became va. Then he wrote down the letter v, then the letter a. Thus, the encoding looked like logva.\n\nIn the second example Polycarp encoded the word no. He wrote down the letter n, the word became o, and he wrote down the letter o. Thus, in this example, the word and its encoding are the same.\n\nIn the third example Polycarp encoded the word baba. At first, he wrote down the letter a, which was at the position 2, after that the word looked like bba. Then he wrote down the letter b, which was at the position 2, his word looked like ba. After that he wrote down the letter b, which was at the position 1, the word looked like a, and he wrote down that letter a. Thus, the encoding is abba.",
        "task_name": "746_B. Decoding",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n=input()\ns=list(raw_input())\nns=''\n\ni=n-2\nwhile(i>=0):\n    ns+=s[i]\n    i-=2\n\nif n%2: i=0\nelse: i=1\n\nwhile(i<n):\n    ns+=s[i]\n    i+=2\n\nprint(ns)\n",
        "correct": true,
        "task_id": "4952"
    },
    {
        "description": "Fox Ciel is going to publish a paper on FOCS (Foxes Operated Computer Systems, pronounce: \"Fox\"). She heard a rumor: the authors list on the paper is always sorted in the lexicographical order. \n\nAfter checking some examples, she found out that sometimes it wasn't true. On some papers authors' names weren't sorted in lexicographical order in normal sense. But it was always true that after some modification of the order of letters in alphabet, the order of authors becomes lexicographical!\n\nShe wants to know, if there exists an order of letters in Latin alphabet such that the names on the paper she is submitting are following in the lexicographical order. If so, you should find out any such order.\n\nLexicographical order is defined in following way. When we compare s and t, first we find the leftmost position with differing characters: si ≠ ti. If there is no such position (i. e. s is a prefix of t or vice versa) the shortest string is less. Otherwise, we compare characters si and ti according to their order in alphabet.\n\nInput\n\nThe first line contains an integer n (1 ≤ n ≤ 100): number of names.\n\nEach of the following n lines contain one string namei (1 ≤ |namei| ≤ 100), the i-th name. Each name contains only lowercase Latin letters. All names are different.\n\nOutput\n\nIf there exists such order of letters that the given names are sorted lexicographically, output any such order as a permutation of characters 'a'–'z' (i. e. first output the first letter of the modified alphabet, then the second, and so on).\n\nOtherwise output a single word \"Impossible\" (without quotes).\n\nExamples\n\nInput\n\n3\nrivest\nshamir\nadleman\n\n\nOutput\n\nbcdefghijklmnopqrsatuvwxyz\n\n\nInput\n\n10\ntourist\npetr\nwjmzbmr\nyeputons\nvepifanov\nscottwu\noooooooooooooooo\nsubscriber\nrowdark\ntankengineer\n\n\nOutput\n\nImpossible\n\n\nInput\n\n10\npetr\negor\nendagorion\nfeferivan\nilovetanyaromanova\nkostka\ndmitriyh\nmaratsnowbear\nbredorjaguarturnik\ncgyforever\n\n\nOutput\n\naghjlnopefikdmbcqrstuvwxyz\n\n\nInput\n\n7\ncar\ncare\ncareful\ncarefully\nbecarefuldontforgetsomething\notherwiseyouwillbehacked\ngoodluck\n\n\nOutput\n\nacbdefhijklmnogpqrstuvwxyz",
        "task_name": "512_A. Fox And Names",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def no():\n    print(\"Impossible\")\n    exit(0)\n\n\nnames = [raw_input() for _ in xrange(input())]\nbefore = {a: set() for a in \"abcdefghijklmnopqrstuvwxyz\"}\n\nfor i in xrange(len(names) - 1):\n    prev_name = names[i]\n    curr_name = names[i + 1]\n    length = min(len(names[i]), len(names[i + 1]))\n    j = 0\n    ok = False\n    while j < length:\n        if prev_name[j] == curr_name[j] or prev_name[j] in before[curr_name[j]]:\n            j += 1\n        else:\n            before[curr_name[j]].update(before[prev_name[j]])\n            before[curr_name[j]].add(prev_name[j])\n            for b in before[curr_name[j]]:\n                if curr_name[j] in before[b]:\n                    no()\n            ok = True\n            break\n    if not ok and len(prev_name) > len(curr_name):\n        no()\n\nans = \"\"\n\nfor i in xrange(26):\n    for b in before:\n        if len(before[b]) == 0:\n            break\n    ans += b\n    before.pop(b)\n    for c in before.values():\n        if b in c:\n            c.remove(b)\n\nprint(ans)\n",
        "correct": false,
        "task_id": "1716"
    },
    {
        "description": "Hacker Zhorik wants to decipher two secret messages he intercepted yesterday. Yeah message is a sequence of encrypted blocks, each of them consists of several bytes of information.\n\nZhorik knows that each of the messages is an archive containing one or more files. Zhorik knows how each of these archives was transferred through the network: if an archive consists of k files of sizes l1, l2, ..., lk bytes, then the i-th file is split to one or more blocks bi, 1, bi, 2, ..., bi, mi (here the total length of the blocks bi, 1 + bi, 2 + ... + bi, mi is equal to the length of the file li), and after that all blocks are transferred through the network, maintaining the order of files in the archive.\n\nZhorik thinks that the two messages contain the same archive, because their total lengths are equal. However, each file can be split in blocks in different ways in the two messages.\n\nYou are given the lengths of blocks in each of the two messages. Help Zhorik to determine what is the maximum number of files could be in the archive, if the Zhorik's assumption is correct.\n\nInput\n\nThe first line contains two integers n, m (1 ≤ n, m ≤ 105) — the number of blocks in the first and in the second messages.\n\nThe second line contains n integers x1, x2, ..., xn (1 ≤ xi ≤ 106) — the length of the blocks that form the first message.\n\nThe third line contains m integers y1, y2, ..., ym (1 ≤ yi ≤ 106) — the length of the blocks that form the second message.\n\nIt is guaranteed that x1 + ... + xn = y1 + ... + ym. Also, it is guaranteed that x1 + ... + xn ≤ 106.\n\nOutput\n\nPrint the maximum number of files the intercepted array could consist of.\n\nExamples\n\nInput\n\n7 6\n2 5 3 1 11 4 4\n7 8 2 4 1 8\n\n\nOutput\n\n3\n\n\nInput\n\n3 3\n1 10 100\n1 100 10\n\n\nOutput\n\n2\n\n\nInput\n\n1 4\n4\n1 1 1 1\n\n\nOutput\n\n1\n\nNote\n\nIn the first example the maximum number of files in the archive is 3. For example, it is possible that in the archive are three files of sizes 2 + 5 = 7, 15 = 3 + 1 + 11 = 8 + 2 + 4 + 1 and 4 + 4 = 8.\n\nIn the second example it is possible that the archive contains two files of sizes 1 and 110 = 10 + 100 = 100 + 10. Note that the order of files is kept while transferring archives through the network, so we can't say that there are three files of sizes 1, 10 and 100.\n\nIn the third example the only possibility is that the archive contains a single file of size 4.",
        "task_name": "950_B. Intercepted Message",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "q1=raw_input().split()\nq2=raw_input().split()\nq3=raw_input().split()\ns1=int(q2[0])\ns2=int(q3[0])\nf=0\np1=0\np2=0\na1=int(q1[0])\na2=int(q1[1])\nwhile((p1<a1)and(p2<a2)):\n    if(s1==s2):\n        s1=0\n        s2=0\n        f=f+1\n        p1=p1+1\n        p2=p2+1\n    if(s1<s2):\n        p1=p1+1\n        s1=s1+int(q2[p1])\n    if(s1>s2):\n        p2=p2+1\n        s2=s2+int(q3[p2])\nprint(f)",
        "correct": false,
        "task_id": "4085"
    },
    {
        "description": "There are n warriors in a row. The power of the i-th warrior is a_i. All powers are pairwise distinct.\n\nYou have two types of spells which you may cast: \n\n  1. Fireball: you spend x mana and destroy exactly k consecutive warriors; \n  2. Berserk: you spend y mana, choose two consecutive warriors, and the warrior with greater power destroys the warrior with smaller power. \n\n\n\nFor example, let the powers of warriors be [2, 3, 7, 8, 11, 5, 4], and k = 3. If you cast Berserk on warriors with powers 8 and 11, the resulting sequence of powers becomes [2, 3, 7, 11, 5, 4]. Then, for example, if you cast Fireball on consecutive warriors with powers [7, 11, 5], the resulting sequence of powers becomes [2, 3, 4].\n\nYou want to turn the current sequence of warriors powers a_1, a_2, ..., a_n into b_1, b_2, ..., b_m. Calculate the minimum amount of mana you need to spend on it.\n\nInput\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 2 ⋅ 10^5) — the length of sequence a and the length of sequence b respectively.\n\nThe second line contains three integers x, k, y (1 ≤ x, y, ≤ 10^9; 1 ≤ k ≤ n) — the cost of fireball, the range of fireball and the cost of berserk respectively.\n\nThe third line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ n). It is guaranteed that all integers a_i are pairwise distinct.\n\nThe fourth line contains m integers b_1, b_2, ..., b_m (1 ≤ b_i ≤ n). It is guaranteed that all integers b_i are pairwise distinct.\n\nOutput\n\nPrint the minimum amount of mana for turning the sequnce a_1, a_2, ..., a_n into b_1, b_2, ..., b_m, or -1 if it is impossible.\n\nExamples\n\nInput\n\n\n5 2\n5 2 3\n3 1 4 5 2\n3 5\n\n\nOutput\n\n\n8\n\n\nInput\n\n\n4 4\n5 1 4\n4 3 1 2\n2 4 3 1\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n4 4\n2 1 11\n1 3 2 4\n1 3 2 4\n\n\nOutput\n\n\n0",
        "task_name": "1380_D. Berserk And Fireball",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "#   Author: yumtam\n#   Created at: 2020-09-10 23:03\n\nfrom __future__ import division, print_function\n_interactive = False\n\ndef main():\n    n, m = input_as_list()\n    x, k, y = input_as_list()\n    a = input_as_list()\n    b = input_as_list()\n\n    j = 0\n    for i, ax in enumerate(a):\n        if j < m and ax == b[j]:\n            j += 1\n\n    if j < m:\n        print(-1)\n        return\n\n    sa = set(a)\n    sb = set(b)\n    if sa == sb:\n        print(0)\n        return\n\n    mx = max(sa-sb)\n\n    gaps = []\n    j = 0\n    gl = 0\n    special = False\n    for i, ax in enumerate(a):\n        if j < m and ax == b[j]:\n            j += 1\n            if special:\n                specialgap = gl\n            gaps.append(gl)\n            gl = 0\n            special = False\n        else:\n            if ax == mx:\n                special = True\n            gl += 1\n    if special:\n        specialgap = gl\n    gaps.append(gl)\n\n    debug_print(gaps)\n\n    if specialgap < k:\n        print(-1)\n        return\n\n    ans = 0\n    if x < y*k:\n        for g in gaps:\n            ans += x*(g//k) + y*(g%k)\n    else:\n        for g in gaps:\n            ans += y*g\n\n    print(ans)\n\n\n# Constants\nINF = float('inf')\nMOD = 10**9+7\n\n# Python3 equivalent names\nimport os, sys, itertools\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n# print-flush in interactive problems\nif _interactive:\n    flush = sys.stdout.flush\n    def printf(*args, **kwargs):\n        print(*args, **kwargs)\n        flush()\n\n# Debug print, only works on local machine\nLOCAL = \"LOCAL_\" in os.environ\ndebug_print = (print) if LOCAL else (lambda *x, **y: None)\n\n# Fast IO\nif (not LOCAL) and (not _interactive):\n    from io import BytesIO\n    from atexit import register\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n    sys.stdout = BytesIO()\n    register(lambda: os.write(1, sys.stdout.getvalue()))\n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Some utility functions(Input, N-dimensional lists, ...)\ndef input_as_list():\n    return [int(x) for x in input().split()]\n\ndef input_with_offset(o):\n    return [int(x)+o for x in input().split()]\n\ndef input_as_matrix(n, m):\n    return [input_as_list() for _ in range(n)]\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\n# Start of external code templates...\n# End of external code templates.\n\nmain()\n",
        "correct": false,
        "task_id": "0909"
    }
]