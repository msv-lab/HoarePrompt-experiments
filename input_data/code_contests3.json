[
    {
        "description": "You are given an array a consisting of n positive integers. You pick two integer numbers l and r from 1 to n, inclusive (numbers are picked randomly, equiprobably and independently). If l > r, then you swap values of l and r. You have to calculate the expected value of the number of unique elements in segment of the array from index l to index r, inclusive (1-indexed).\n\nInput\n\nThe first line contains one integer number n (1 ≤ n ≤ 106). The second line contains n integer numbers a1, a2, ... an (1 ≤ ai ≤ 106) — elements of the array.\n\nOutput\n\nPrint one number — the expected number of unique elements in chosen segment. \n\nYour answer will be considered correct if its absolute or relative error doesn't exceed 10 - 4 — formally, the answer is correct if <image>, where x is jury's answer, and y is your answer.\n\nExamples\n\nInput\n\n2\n1 2\n\n\nOutput\n\n1.500000\n\n\nInput\n\n2\n2 2\n\n\nOutput\n\n1.000000",
        "task_name": "846_F. Random Query",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\narr = map(int,raw_input().split(\" \"))\n\nreq = len(set(arr))\n\nprint ((req + 1))/2",
        "correct": false,
        "task_id": "2845"
    },
    {
        "description": "International Women's Day is coming soon! Polycarp is preparing for the holiday.\n\nThere are n candy boxes in the shop for sale. The i-th box contains d_i candies.\n\nPolycarp wants to prepare the maximum number of gifts for k girls. Each gift will consist of exactly two boxes. The girls should be able to share each gift equally, so the total amount of candies in a gift (in a pair of boxes) should be divisible by k. In other words, two boxes i and j (i ≠ j) can be combined as a gift if d_i + d_j is divisible by k.\n\nHow many boxes will Polycarp be able to give? Of course, each box can be a part of no more than one gift. Polycarp cannot use boxes \"partially\" or redistribute candies between them. \n\nInput\n\nThe first line of the input contains two integers n and k (1 ≤ n ≤ 2 ⋅ 10^5, 1 ≤ k ≤ 100) — the number the boxes and the number the girls.\n\nThe second line of the input contains n integers d_1, d_2, ..., d_n (1 ≤ d_i ≤ 10^9), where d_i is the number of candies in the i-th box.\n\nOutput\n\nPrint one integer — the maximum number of the boxes Polycarp can give as gifts.\n\nExamples\n\nInput\n\n\n7 2\n1 2 2 3 2 4 10\n\n\nOutput\n\n\n6\n\n\nInput\n\n\n8 2\n1 2 2 3 2 4 6 10\n\n\nOutput\n\n\n8\n\n\nInput\n\n\n7 3\n1 2 2 3 2 4 5\n\n\nOutput\n\n\n4\n\nNote\n\nIn the first example Polycarp can give the following pairs of boxes (pairs are presented by indices of corresponding boxes): \n\n  * (2, 3); \n  * (5, 6); \n  * (1, 4). \n\n\n\nSo the answer is 6.\n\nIn the second example Polycarp can give the following pairs of boxes (pairs are presented by indices of corresponding boxes): \n\n  * (6, 8); \n  * (2, 3); \n  * (1, 4); \n  * (5, 7). \n\n\n\nSo the answer is 8.\n\nIn the third example Polycarp can give the following pairs of boxes (pairs are presented by indices of corresponding boxes): \n\n  * (1, 2); \n  * (6, 7). \n\n\n\nSo the answer is 4.",
        "task_name": "1133_B. Preparation for International Women's Day",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "l, k = map(lambda i: int(i), raw_input().split(' '))\ncandy_list = map(lambda i: int(i), raw_input().split(' '))\n\ndef max_boxes(k, candy_array):\n    res_map = {}\n    res = 0\n    for candy in candy_array:\n        if res_map.has_key(k - candy % k) and res_map[k - candy % k] > 0:\n            res += 2\n            res_map[k - candy % k] = res_map[k - candy % k] - 1\n        else:\n            res_map[candy % k] = res_map[candy % k] + 1 if res_map.has_key(candy % k) else 1\n    print(res)\n\nmax_boxes(k, candy_list)\n",
        "correct": false,
        "task_id": "2685"
    },
    {
        "description": "Given are a positive integer N and a sequence of length 2^N consisting of 0s and 1s: A_0,A_1,\\ldots,A_{2^N-1}. Determine whether there exists a closed curve C that satisfies the condition below for all 2^N sets S \\subseteq \\\\{0,1,\\ldots,N-1 \\\\}. If the answer is yes, construct one such closed curve.\n\n* Let x = \\sum_{i \\in S} 2^i and B_S be the set of points \\\\{ (i+0.5,0.5) | i \\in S \\\\}.\n* If there is a way to continuously move the closed curve C without touching B_S so that every point on the closed curve has a negative y-coordinate, A_x = 1.\n* If there is no such way, A_x = 0.\n\n\n\nFor instruction on printing a closed curve, see Output below.\n\nConstraints\n\n* 1 \\leq N \\leq 8\n* A_i = 0,1 \\quad (0 \\leq i \\leq 2^N-1)\n* A_0 = 1\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nA_0A_1 \\cdots A_{2^N-1}\n\n\nOutput\n\nIf there is no closed curve that satisfies the condition, print `Impossible`.\n\nIf such a closed curve exists, print `Possible` in the first line. Then, print one such curve in the following format:\n\n\nL\nx_0 y_0\nx_1 y_1\n:\nx_L y_L\n\n\nThis represents the closed polyline that passes (x_0,y_0),(x_1,y_1),\\ldots,(x_L,y_L) in this order.\n\nHere, all of the following must be satisfied:\n\n* 0 \\leq x_i \\leq N, 0 \\leq y_i \\leq 1, and x_i, y_i are integers. (0 \\leq i \\leq L)\n* |x_i-x_{i+1}| + |y_i-y_{i+1}| = 1. (0 \\leq i \\leq L-1)\n* (x_0,y_0) = (x_L,y_L).\n\n\n\nAdditionally, the length of the closed curve L must satisfy 0 \\leq L \\leq 250000.\n\nIt can be proved that, if there is a closed curve that satisfies the condition in Problem Statement, there is also a closed curve that can be expressed in this format.\n\nExamples\n\nInput\n\n1\n10\n\n\nOutput\n\nPossible\n4\n0 0\n0 1\n1 1\n1 0\n0 0\n\n\nInput\n\n2\n1000\n\n\nOutput\n\nPossible\n6\n1 0\n2 0\n2 1\n1 1\n0 1\n0 0\n1 0\n\n\nInput\n\n2\n1001\n\n\nOutput\n\nImpossible\n\n\nInput\n\n1\n11\n\n\nOutput\n\nPossible\n0\n1 1",
        "task_name": "p02739 AtCoder Grand Contest 043 - Topology",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def rev(a):\n    return [-v for v in a]\n\ndef make(s):\n    assert len(s)>0\n    pre_s = s[:-1]\n    v = s[-1]\n    if len(pre_s)==0:\n        return [v]\n    return make(pre_s) + [v] + rev(make(pre_s)) + [-v]\n\ndef make_pre_path(v):\n    if v>0:\n        return [(i,0) for i in range(1,v+1)] + [(v,1), (v-1,1)] + [(i,0) for i in range(v-1,0,-1)]\n    elif v<0:\n        return make_pre_path(-v)[::-1]\n    assert False\n\ndef make_path(v):\n    return make_pre_path(v)+[(0,0)]\n\ndef test():\n    #print(make([1,2,3]))\n    main(\"1\",\"11\")\n    #main(\"8\",\"1\"+\"0\"*(2**8-1))\n\ndef main(s1,s2):\n    ok = True\n    n = int(s1)\n    ret_gp = []\n    for i in range(2**n-1,-1,-1):\n        s = [v+1 for v in range(n) if (i>>v)%2==1 ]\n        if s2[i]==\"0\":\n            for ind in range(n):\n                if (i>>ind)%2==0 and s2[(i+2**ind)]==\"1\":\n                    ok = False\n            ret_gp += make(s)\n    ret_path = [(0,0)] + [p for v in ret_gp for p in make_path(v)]\n    if ok:\n        print(\"Possible\")\n        print(len(ret_path) - 1)\n        for x,y in ret_path:\n            print(str(x)+\" \"+str(y))\n    else:\n        print(\"Impossible\")\n\ns1 = raw_input()\ns2 = raw_input()\nmain(s1,s2)",
        "correct": false,
        "task_id": "4175"
    },
    {
        "description": "Let's denote a function \n\n<image>\n\nYou are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.\n\nInput\n\nThe first line contains one integer n (1 ≤ n ≤ 200000) — the number of elements in a.\n\nThe second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — elements of the array. \n\nOutput\n\nPrint one integer — the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.\n\nExamples\n\nInput\n\n5\n1 2 3 1 3\n\n\nOutput\n\n4\n\n\nInput\n\n4\n6 6 5 5\n\n\nOutput\n\n0\n\n\nInput\n\n4\n6 6 4 4\n\n\nOutput\n\n-8\n\nNote\n\nIn the first example:\n\n  1. d(a1, a2) = 0; \n  2. d(a1, a3) = 2; \n  3. d(a1, a4) = 0; \n  4. d(a1, a5) = 2; \n  5. d(a2, a3) = 0; \n  6. d(a2, a4) = 0; \n  7. d(a2, a5) = 0; \n  8. d(a3, a4) = - 2; \n  9. d(a3, a5) = 0; \n  10. d(a4, a5) = 2. ",
        "task_name": "903_D. Almost Difference",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "n = int(raw_input())\na = list(map(int, raw_input().split()))\nsm = 0\nm = dict()\nans = 0\nfor i in range(n-1, -1, -1):\n    cnt = 0\n    diff = 0\n    if a[i] in m:\n        cnt += m[a[i]]\n        diff += a[i]*m[a[i]]\n    if a[i]+1 in m:\n        cnt += m[a[i]+1]\n        diff += (a[i]+1)*m[a[i]+1]\n    if a[i]-1 in m:\n        cnt += m[a[i]-1]\n        diff += (a[i]-1)*m[a[i]-1]\n    ans += sm-diff-a[i]*(n-i-1-cnt)\n    sm += a[i]\n    if a[i] in m:\n        m[a[i]] += 1\n    else:\n        m[a[i]] = 1\nprint(ans)\n",
        "correct": true,
        "task_id": "0200"
    },
    {
        "description": "The city Valera lives in is going to hold elections to the city Parliament.\n\nThe city has n districts and n - 1 bidirectional roads. We know that from any district there is a path along the roads to any other district. Let's enumerate all districts in some way by integers from 1 to n, inclusive. Furthermore, for each road the residents decided if it is the problem road or not. A problem road is a road that needs to be repaired.\n\nThere are n candidates running the elections. Let's enumerate all candidates in some way by integers from 1 to n, inclusive. If the candidate number i will be elected in the city Parliament, he will perform exactly one promise — to repair all problem roads on the way from the i-th district to the district 1, where the city Parliament is located.\n\nHelp Valera and determine the subset of candidates such that if all candidates from the subset will be elected to the city Parliament, all problem roads in the city will be repaired. If there are several such subsets, you should choose the subset consisting of the minimum number of candidates.\n\nInput\n\nThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of districts in the city.\n\nThen n - 1 lines follow. Each line contains the description of a city road as three positive integers xi, yi, ti (1 ≤ xi, yi ≤ n, 1 ≤ ti ≤ 2) — the districts connected by the i-th bidirectional road and the road type. If ti equals to one, then the i-th road isn't the problem road; if ti equals to two, then the i-th road is the problem road.\n\nIt's guaranteed that the graph structure of the city is a tree.\n\nOutput\n\nIn the first line print a single non-negative number k — the minimum size of the required subset of candidates. Then on the second line print k space-separated integers a1, a2, ... ak — the numbers of the candidates that form the required subset. If there are multiple solutions, you are allowed to print any of them.\n\nExamples\n\nInput\n\n5\n1 2 2\n2 3 2\n3 4 2\n4 5 2\n\n\nOutput\n\n1\n5 \n\n\nInput\n\n5\n1 2 1\n2 3 2\n2 4 1\n4 5 1\n\n\nOutput\n\n1\n3 \n\n\nInput\n\n5\n1 2 2\n1 3 2\n1 4 2\n1 5 2\n\n\nOutput\n\n4\n5 4 3 2 ",
        "task_name": "369_C. Valera and Elections",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "def dfs(no, grafo, visitados, depth, cand):\n    if no[1]:\n        cand['value'] = max(cand['value'], no[0])\n    visitados[no[0]] = True\n\n    for vizinho in grafo[no[0]]:\n        if not visitados[vizinho[0]]:\n            dfs(vizinho, grafo, visitados, depth+1, cand)\n            \nn = int(raw_input())\ngrafo = [[] for _ in xrange(n+1)]\n\n\nfor i in xrange(1,n):\n    a,b,t = map(int, raw_input().split())\n    grafo[a].append((b,False if t == 1 else True))\n    grafo[b].append((a,False if t == 1 else True))\n\n\n\nvisitados = [False for _ in xrange(n+1)]\nvizinhos = grafo[1]\nvisitados[1] = True\ncandi = []\nfor vizinho in vizinhos:\n    maxi = {'value':-1}\n    dfs(vizinho, grafo, visitados,1, maxi)\n    if(maxi['value'] != -1):\n        candi.append(maxi['value'])\nprint(len(set(candi)))\nprint(\" \".join(list(set(map(str, candi)))))\n\n    \n    \n",
        "correct": false,
        "task_id": "4204"
    }
]