[
    {
        "description": "There are two popular keyboard layouts in Berland, they differ only in letters positions. All the other keys are the same. In Berland they use alphabet with 26 letters which coincides with English alphabet.\n\nYou are given two strings consisting of 26 distinct letters each: all keys of the first and the second layouts in the same order. \n\nYou are also given some text consisting of small and capital English letters and digits. It is known that it was typed in the first layout, but the writer intended to type it in the second layout. Print the text if the same keys were pressed in the second layout.\n\nSince all keys but letters are the same in both layouts, the capitalization of the letters should remain the same, as well as all other characters.\n\nInput\n\nThe first line contains a string of length 26 consisting of distinct lowercase English letters. This is the first layout.\n\nThe second line contains a string of length 26 consisting of distinct lowercase English letters. This is the second layout.\n\nThe third line contains a non-empty string s consisting of lowercase and uppercase English letters and digits. This is the text typed in the first layout. The length of s does not exceed 1000.\n\nOutput\n\nPrint the text if the same keys were pressed in the second layout.\n\nExamples\n\nInput\n\nqwertyuiopasdfghjklzxcvbnm\nveamhjsgqocnrbfxdtwkylupzi\nTwccpQZAvb2017\n\n\nOutput\n\nHelloVKCup2017\n\n\nInput\n\nmnbvcxzlkjhgfdsapoiuytrewq\nasdfghjklqwertyuiopzxcvbnm\n7abaCABAABAcaba7\n\n\nOutput\n\n7uduGUDUUDUgudu7",
        "task_name": "831_B. Keyboard Layouts",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "layout1 = raw_input()\nlayout2 = raw_input()\ns = raw_input()\nMods=''\n\ndic = {}\nfor i in range(26):\n\tdic[layout1[i]] = i\nfor i in range(len(s)):\n\tif s[i].isdigit():\n\t\tMods += s[i]\n\telif s[i].isupper():\n\t\tMods += layout2[dic[s[i].lower()]].upper()\n\telse:\n\t\tMods += layout2[dic[s[i]]]\nprint(Mods)\n",
        "correct": true,
        "task_id": "4586"
    },
    {
        "description": "Kostya is a genial sculptor, he has an idea: to carve a marble sculpture in the shape of a sphere. Kostya has a friend Zahar who works at a career. Zahar knows about Kostya's idea and wants to present him a rectangular parallelepiped of marble from which he can carve the sphere. \n\nZahar has n stones which are rectangular parallelepipeds. The edges sizes of the i-th of them are ai, bi and ci. He can take no more than two stones and present them to Kostya. \n\nIf Zahar takes two stones, he should glue them together on one of the faces in order to get a new piece of rectangular parallelepiped of marble. Thus, it is possible to glue a pair of stones together if and only if two faces on which they are glued together match as rectangles. In such gluing it is allowed to rotate and flip the stones in any way. \n\nHelp Zahar choose such a present so that Kostya can carve a sphere of the maximum possible volume and present it to Zahar.\n\nInput\n\nThe first line contains the integer n (1 ≤ n ≤ 105).\n\nn lines follow, in the i-th of which there are three integers ai, bi and ci (1 ≤ ai, bi, ci ≤ 109) — the lengths of edges of the i-th stone. Note, that two stones may have exactly the same sizes, but they still will be considered two different stones.\n\nOutput\n\nIn the first line print k (1 ≤ k ≤ 2) the number of stones which Zahar has chosen. In the second line print k distinct integers from 1 to n — the numbers of stones which Zahar needs to choose. Consider that stones are numbered from 1 to n in the order as they are given in the input data.\n\nYou can print the stones in arbitrary order. If there are several answers print any of them. \n\nExamples\n\nInput\n\n6\n5 5 5\n3 2 4\n1 4 1\n2 1 3\n3 2 4\n3 3 4\n\n\nOutput\n\n1\n1\n\n\nInput\n\n7\n10 7 8\n5 10 3\n4 2 6\n5 5 5\n10 2 8\n4 2 1\n7 7 7\n\n\nOutput\n\n2\n1 5\n\nNote\n\nIn the first example we can connect the pairs of stones:\n\n  * 2 and 4, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1\n  * 2 and 5, the size of the parallelepiped: 3 × 2 × 8 or 6 × 2 × 4 or 3 × 4 × 4, the radius of the inscribed sphere 1, or 1, or 1.5 respectively. \n  * 2 and 6, the size of the parallelepiped: 3 × 5 × 4, the radius of the inscribed sphere 1.5\n  * 4 and 5, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1\n  * 5 and 6, the size of the parallelepiped: 3 × 4 × 5, the radius of the inscribed sphere 1.5\n\n\n\nOr take only one stone:\n\n  * 1 the size of the parallelepiped: 5 × 5 × 5, the radius of the inscribed sphere 2.5\n  * 2 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1\n  * 3 the size of the parallelepiped: 1 × 4 × 1, the radius of the inscribed sphere 0.5\n  * 4 the size of the parallelepiped: 2 × 1 × 3, the radius of the inscribed sphere 0.5\n  * 5 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1\n  * 6 the size of the parallelepiped: 3 × 3 × 4, the radius of the inscribed sphere 1.5\n\n\n\nIt is most profitable to take only the first stone. ",
        "task_name": "733_D. Kostya the Sculptor",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from sys import stdin, stdout\nn = int(stdin.readline())\n\none = {}\ntwo = {}\nans = []\nchallengers = []\nfor i in range(n):\n    a, b, c = map(int, stdin.readline().split())\n    challengers.append((a, b, c))\n    \n    first = (max(a, b), min(a, b))\n    second = (max(a, c), min(a, c))\n    third = (max(b, c), min(b, c))\n    \n    if first in two:\n        if two[first] < one[first][0] + c:\n            ans.append((one[first][0] + c, first[0], first[1], one[first][1], i))\n            two[first] = one[first][0] + c\n    elif first in one:\n        two[first] = one[first][0] + c\n        ans.append((one[first][0] + c, first[0], first[1], one[first][1], i))\n    \n    if second in two:\n        if two[second] < one[second][0] + c:\n            ans.append((one[second][0] + b, second[0], second[1], one[second][1], i))\n            two[second] = one[second][0] + b\n    elif second in one:\n        two[second] = one[second][0] + b    \n        ans.append((one[second][0] + b, second[0], second[1], one[second][1], i))        \n        \n    if third in two:\n        if two[third] < one[third][0] + c:\n            ans.append((one[third][0] + a, third[0], third[1], one[third][1], i))\n            two[third] = one[third][0] + a\n    elif third in one:\n        two[third] = one[third][0] + a\n        ans.append((one[third][0] + a, third[0], third[1], one[third][1], i))\n    \n    if first not in one or one[first][0] < c:\n        one[first] = (c, i)\n    \n    if second not in one or one[second][0] < b:\n        one[second] = (b, i)\n    \n    if third not in one or one[third][0] < a:\n        one[third] = (a, i)\n\nlabel = 0\ncnt = 0\nfor a, b, c, ind1, ind2 in ans:\n    if min(min(a, b), c) > cnt:\n        label = 2\n        cnt = min(min(a, b), c)\n        first = ind1\n        second = ind2\n\nfor i in range(n):\n    a, b, c = challengers[i]\n    if min(min(a, b), c) > cnt:\n        label = 1\n        cnt = min(min(a, b), c)\n        first = i\n\nif label == 1:\n    stdout.write('1' + '\\n' + str(first + 1))\nelse:\n    stdout.write('2' + '\\n' + str(first + 1) + ' ' + str(second + 1))",
        "correct": true,
        "task_id": "1422"
    },
    {
        "description": "Petya and Vasya are playing a game. Petya's got n non-transparent glasses, standing in a row. The glasses' positions are indexed with integers from 1 to n from left to right. Note that the positions are indexed but the glasses are not.\n\nFirst Petya puts a marble under the glass in position s. Then he performs some (possibly zero) shuffling operations. One shuffling operation means moving the glass from the first position to position p1, the glass from the second position to position p2 and so on. That is, a glass goes from position i to position pi. Consider all glasses are moving simultaneously during one shuffling operation. When the glasses are shuffled, the marble doesn't travel from one glass to another: it moves together with the glass it was initially been put in.\n\nAfter all shuffling operations Petya shows Vasya that the ball has moved to position t. Vasya's task is to say what minimum number of shuffling operations Petya has performed or determine that Petya has made a mistake and the marble could not have got from position s to position t.\n\nInput\n\nThe first line contains three integers: n, s, t (1 ≤ n ≤ 105; 1 ≤ s, t ≤ n) — the number of glasses, the ball's initial and final position. The second line contains n space-separated integers: p1, p2, ..., pn (1 ≤ pi ≤ n) — the shuffling operation parameters. It is guaranteed that all pi's are distinct.\n\nNote that s can equal t.\n\nOutput\n\nIf the marble can move from position s to position t, then print on a single line a non-negative integer — the minimum number of shuffling operations, needed to get the marble to position t. If it is impossible, print number -1.\n\nExamples\n\nInput\n\n4 2 1\n2 3 4 1\n\n\nOutput\n\n3\n\n\nInput\n\n4 3 3\n4 1 3 2\n\n\nOutput\n\n0\n\n\nInput\n\n4 3 4\n1 2 3 4\n\n\nOutput\n\n-1\n\n\nInput\n\n3 1 3\n2 1 3\n\n\nOutput\n\n-1",
        "task_name": "285_B. Find Marble",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "IN = lambda: map(int, raw_input().split())\nprint -(sum(IN())-sum(IN()))\n",
        "correct": false,
        "task_id": "2005"
    },
    {
        "description": "Let a and b be two arrays of lengths n and m, respectively, with no elements in common. We can define a new array merge(a,b) of length n+m recursively as follows:\n\n  * If one of the arrays is empty, the result is the other array. That is, merge(∅,b)=b and merge(a,∅)=a. In particular, merge(∅,∅)=∅. \n  * If both arrays are non-empty, and a_1<b_1, then merge(a,b)=[a_1]+merge([a_2,…,a_n],b). That is, we delete the first element a_1 of a, merge the remaining arrays, then add a_1 to the beginning of the result. \n  * If both arrays are non-empty, and a_1>b_1, then merge(a,b)=[b_1]+merge(a,[b_2,…,b_m]). That is, we delete the first element b_1 of b, merge the remaining arrays, then add b_1 to the beginning of the result. \n\n\n\nThis algorithm has the nice property that if a and b are sorted, then merge(a,b) will also be sorted. For example, it is used as a subroutine in merge-sort. For this problem, however, we will consider the same procedure acting on non-sorted arrays as well. For example, if a=[3,1] and b=[2,4], then merge(a,b)=[2,3,1,4].\n\nA permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\n\nThere is a permutation p of length 2n. Determine if there exist two arrays a and b, each of length n and with no elements in common, so that p=merge(a,b).\n\nInput\n\nThe first line contains a single integer t (1≤ t≤ 1000) — the number of test cases. Next 2t lines contain descriptions of test cases. \n\nThe first line of each test case contains a single integer n (1≤ n≤ 2000).\n\nThe second line of each test case contains 2n integers p_1,…,p_{2n} (1≤ p_i≤ 2n). It is guaranteed that p is a permutation.\n\nIt is guaranteed that the sum of n across all test cases does not exceed 2000.\n\nOutput\n\nFor each test case, output \"YES\" if there exist arrays a, b, each of length n and with no common elements, so that p=merge(a,b). Otherwise, output \"NO\".\n\nExample\n\nInput\n\n\n6\n2\n2 3 1 4\n2\n3 1 2 4\n4\n3 2 6 1 5 7 8 4\n3\n1 2 3 4 5 6\n4\n6 1 3 7 4 5 8 2\n6\n4 3 2 5 1 11 9 12 8 6 10 7\n\n\nOutput\n\n\nYES\nNO\nYES\nYES\nNO\nNO\n\nNote\n\nIn the first test case, [2,3,1,4]=merge([3,1],[2,4]).\n\nIn the second test case, we can show that [3,1,2,4] is not the merge of two arrays of length 2.\n\nIn the third test case, [3,2,6,1,5,7,8,4]=merge([3,2,8,4],[6,1,5,7]).\n\nIn the fourth test case, [1,2,3,4,5,6]=merge([1,3,6],[2,4,5]), for example.",
        "task_name": "1381_B. Unmerge",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "from collections import *\nimport sys\ntry: inp = raw_input\nexcept: inp = input\ndef err(s):\n    sys.stderr.write('{}\\n'.format(s))\n\ndef ni():\n    return int(inp())\n\ndef nl():\n    return [int(_) for _ in inp().split()]\n\ndef solve(N):\n    P = nl()\n\n    a = [10**5]\n    b = [10**5]\n    fail = False\n    for c in P[::-1]:\n        if len(a) == 1:\n            a.append(c)\n            continue\n        if c > a[-1] and c > b[-1]:\n            fail = True\n            break\n        if c > a[-1]:\n            a.append(c)\n            continue\n        if c > b[-1]:\n            b.append(c)\n            continue\n        if (len(b), b[-1]) < (len(a), a[-1]):\n            b.append(c)\n        else:\n            a.append(c)\n    if len(a) != N +1: fail = True\n    if fail:\n        print('NO')\n    else:\n        print('YES')\n\nt = ni()\nfor _ in range(t):\n    N = ni()\n    solve(N)\n",
        "correct": false,
        "task_id": "1326"
    },
    {
        "description": "In some village, there are 999 towers that are 1,(1+2),(1+2+3),...,(1+2+3+...+999) meters high from west to east, at intervals of 1 meter.\n\nIt had been snowing for a while before it finally stopped. For some two adjacent towers located 1 meter apart, we measured the lengths of the parts of those towers that are not covered with snow, and the results are a meters for the west tower, and b meters for the east tower.\n\nAssuming that the depth of snow cover and the altitude are the same everywhere in the village, find the amount of the snow cover.\n\nAssume also that the depth of the snow cover is always at least 1 meter.\n\nConstraints\n\n* 1 \\leq a < b < 499500(=1+2+3+...+999)\n* All values in input are integers.\n* There is no input that contradicts the assumption.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\na b\n\n\nOutput\n\nIf the depth of the snow cover is x meters, print x as an integer.\n\nExamples\n\nInput\n\n8 13\n\n\nOutput\n\n2\n\n\nInput\n\n54 65\n\n\nOutput\n\n1",
        "task_name": "p03328 AtCoder Beginner Contest 099 - Stone Monument",
        "dataset": "code_contests",
        "model": "human",
        "generated_code": "a,b = map(int, raw_input().split())\nprint (b-a)*(b-a-1)/2-a\n",
        "correct": true,
        "task_id": "3141"
    }
]